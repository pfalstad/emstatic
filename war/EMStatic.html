<!doctype html>
<!-- The DOCTYPE declaration above will set the     -->
<!-- browser's rendering engine into                -->
<!-- "Standards Mode". Replacing this declaration   -->
<!-- with a "Quirks Mode" doctype is not supported. -->

<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

<style>
.disabled {
        color: lightgray
}
.topSpace {
        margin-top: 12px;
}

.gwt-MenuItem-disabled {
        color: lightgray;
}
.offScreen {
        position: absolute;
        right: 101%;
        overflow: hidden;
}
.gwt-Frame{
        scrolling="no";
        border: 0px !important;
}

.gwt-MenuItem {
        font-size: 12px !important;
}

.gwt-MenuBar-horizontal {
        font-size: 12px !important;
        }
        
.gwt-Label-selected {
        font-size: 1.3em;
        font-weight: 700;
        border-top: 1px solid black;
        border-bottom: 1px solid black;
}
.gwt-Label-1off {
        color: DarkGray;
}

.gwt-Label-2off {
        font-size:0.8em;
        color: LightGray;
}

.gwt-Label-current {
}


</style>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="shader-display-fs" type="x-shader/x-fragment">
#define TS_COL_WALL 0
#define TS_COL_POS 1
#define TS_COL_NEG 2
#define TS_COL_NEUTRAL 3
#define TS_COL_POS_MED 4
#define TS_COL_NEG_MED 5
#define TS_COL_MED 6
#define TS_COL_SOURCE 7
#define TS_COL_COUNT  9

    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;

    uniform sampler2D uSampler;
    uniform float brightness;
    uniform lowp vec3 colors[TS_COL_COUNT];

	// shader for displaying waves on screen
    void main(void) {
        float alpha = 1.0;
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));

		// blue channel used to store walls/media
		float med = textureColor.b;
		vec3 col;
		if (med == 0.0)
			col = colors[TS_COL_WALL];
		else {
			// red channel used to store wave height
			float r =  textureColor.r*brightness;
	        r = clamp(r, -1., 1.);
            if (r > 0.0)
            	col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                			mix(colors[TS_COL_POS_MED], colors[TS_COL_POS], med), r);
            else
                col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                		    mix(colors[TS_COL_NEG_MED], colors[TS_COL_NEG], med), -r);
		}
//gl_FragColor = vec4(textureColor.rgb * brightness, 1.);
        gl_FragColor = vec4(col, 1.);
    }
</script>

<script id="shader-equipotential-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;
    uniform float stepSizeX;
    uniform float stepSizeY;
    uniform float brightness;

    void main(void) {
        float alpha = 1.0;
        vec4 texture0 = texture2D(uSampler, vec2(vTextureCoord.s-stepSizeX, vTextureCoord.t));
        vec4 textureS = texture2D(uSampler, vec2(vTextureCoord.s+stepSizeX, vTextureCoord.t));
        vec4 textureA = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t-stepSizeY));
        vec4 textureT = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t+stepSizeY));

	float pot0 =  texture0.r*brightness;
	float potS =  textureS.r*brightness;
	float potT =  textureT.r*brightness;
	float potA =  textureA.r*brightness;
        gl_FragColor = (floor(pot0) != floor(potS) || floor(potA) != floor(potT)) ? vec4(1., 1., 1., 1.) : vec4(0., 0., 0., 0.);
    }
</script>

<script id="shader-draw-fs" type="x-shader/x-fragment">
    precision mediump float;

    //varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-draw-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
		vColor = aColor;
    }
</script>

<script id="shader-mode-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
		// used to paint mode boxes
        gl_FragColor = vec4(sin(vColor.r)*sin(vColor.g)+sin(vColor.b)*sin(vColor.a), 0., 0., 0.);
    }
</script>

<script id="shader-copy-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    uniform sampler2D uSourceTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        gl_FragColor = vec4(pv.rg, 1., 1.);
}

</script>

<script id="shader-simulate-fs" type="x-shader/x-fragment">
	// shader for running simulation
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;

highp vec4 getSquare(highp vec2 offset)
{
        highp vec2 x = offset+vTextureCoord;
	highp vec4 q = texture2D(uSourceTexture, x);
	highp vec4 q2 = texture2D(uRightSideTexture, x);
        // switch conductors to space to avoid problems with charged conductors (need a better way to fix this)
        return vec4(q.r, q.g, q2.b > 0.0 ? q2.b : 1.0, q2.a);
}

void main()
{
    	highp float newpos = 0.;
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        if (rv.b > 0.0) {
                highp vec4 mid1 = getSquare(vec2(stepSizeX, 0.));
                highp vec4 mid2 = getSquare(vec2(-stepSizeX, 0.));
                highp vec4 mid3 = getSquare(vec2(0., stepSizeY));
                highp vec4 mid4 = getSquare(vec2(0., -stepSizeY));
		newpos = (mid1.r*mid1.b + mid2.r*mid2.b + mid3.r*mid3.b + mid4.r*mid4.b)/(mid1.b+mid2.b+mid3.b+mid4.b) +
		         .25*(rv.r*stepSizeX*stepSizeY/rv.b);
        } else
		newpos = rv.r;
        gl_FragColor = vec4(newpos, 0., pv.b, 1.);
}

</script>

<script id="shader-residual-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;

highp vec4 getSquare(highp vec2 offset)
{
        highp vec2 x = offset+vTextureCoord;
	return texture2D(uSourceTexture, x);
}

void main()
{
    	highp float newpos = 0.;
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        if (rv.b > 0.0) {
                highp float pos = pv.r;
                highp vec4 mid1 = getSquare(vec2(stepSizeX, 0.));
                highp vec4 mid2 = getSquare(vec2(-stepSizeX, 0.));
                highp vec4 mid3 = getSquare(vec2(0., stepSizeY));
                highp vec4 mid4 = getSquare(vec2(0., -stepSizeY));
		newpos = (4./(stepSizeX*stepSizeY)) *
                        ((mid1.r*mid1.b + mid2.r*mid2.b + mid3.r*mid3.b + mid4.r*mid4.b)/(mid1.b+mid2.b+mid3.b+mid4.b) - pos) + rv.r/rv.b;
        }
        //gl_FragColor = vec4(newpos, 0.0, pv.b, 1.);
        //gl_FragColor = vec4(newpos, 0.0, rv.b, 1.);
        gl_FragColor = vec4(newpos, 0.0, 1., 1.);
}

</script>

<script id="shader-add-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        gl_FragColor = pv+rv;
}

</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute float aDamping;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;


    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
	vDamping = aDamping;
    }
</script>

<script id="shader-3d-vs" type="x-shader/x-vertex">
#define TS_COL_WALL 0
#define TS_COL_POS 1
#define TS_COL_NEG 2

#define TS_COL_POS_MED 4
#define TS_COL_NEG_MED 5
#define TS_COL_MED 6
#define TS_COL_SOURCE 7
#define TS_COL_NEUTRAL 8
#define TS_COL_COUNT 9

    attribute highp vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
	uniform highp float xOffset;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
	varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float brightness;
    uniform lowp vec3 colors[TS_COL_COUNT];

    void main(void) {
		highp vec2 tc  = vec2(aTextureCoord.x+xOffset, aTextureCoord.y);
        vec4 pv = texture2D(uSampler, tc);
		float r =  pv.r*brightness;
        vPosition = uMVMatrix * vec4(-1.0+2.0*tc.x, -1.0+2.0*tc.y, r, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = tc;
		float med = pv.b;
		vec3 col;
		if (med == 0.0)
			col = colors[TS_COL_WALL];
		else {
			// calculate normal
			float qx = texture2D(uSampler, vec2(aTextureCoord.x+xOffset+1./200., aTextureCoord.y)).r-pv.r;
			float qy = texture2D(uSampler, vec2(aTextureCoord.x+xOffset, aTextureCoord.y+1./200.)).r-pv.r;
			qx *= brightness;  qy *= brightness;

			// calculate lighting
			float normdot = (qx+qy+0.1)*(1./1.73)/length(vec3(qx, qy, 0.1));
	        r = 40.*clamp(r, -1., 1.);
                if (r > 0.0)
                        col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                      mix(colors[TS_COL_POS_MED], colors[TS_COL_POS], med), r);
                else
                        col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                      mix(colors[TS_COL_NEG_MED], colors[TS_COL_NEG], med), -r);
			col = mix(col, vec3(1., 1., 1.), normdot);
		}
        vColor = vec4(col, 1.);

    }
</script>

<script id="shader-field-vs" type="x-shader/x-vertex">

attribute highp vec2 aVertexPosition;
uniform sampler2D uSampler;
varying vec3 vColor;
uniform float stepSizeX;
uniform float stepSizeY;
uniform float brightness;
varying mat2 vMatrix;
uniform mat3 uTextureMatrix;

highp vec4 getSquare(highp vec2 coords, highp float offsetX, highp float offsetY) {
  return texture2D(uSampler, (uTextureMatrix * vec3(coords.x+offsetX, coords.y+offsetY, 1)).xy);
}

void main() {
  highp vec4 pa = getSquare(aVertexPosition,  stepSizeX, 0.);
  highp vec4 pb = getSquare(aVertexPosition, -stepSizeX, 0.);
  highp vec4 pc = getSquare(aVertexPosition, 0.,  stepSizeY);
  highp vec4 pd = getSquare(aVertexPosition, 0., -stepSizeY);
  vec2 grad = -vec2(pb.r-pa.r, pc.r-pd.r);
  float len = length(grad);
  float col = len*brightness*10.0;
  vColor = col > 1.0 ? vec3(col-1.0, 1.0, col-1.0) : vec3(0.0, col, 0.0);
  vMatrix = mat2(grad.y/len, grad.x/len, -grad.x/len, grad.y/len);
  gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
  gl_PointSize = 12.0;
  
}

</script>

<script id="shader-field-fs" type="x-shader/x-fragment">

varying highp vec3 vColor;
varying highp mat2 vMatrix;
uniform sampler2D uArrowTexture;

void main() {
  highp vec2 pc = gl_PointCoord;
  pc = vMatrix*(pc-vec2(0.5, 0.5)) + vec2(0.5, 0.5);
  gl_FragColor = vec4(texture2D(uArrowTexture, pc).rgb * vColor, 1.0);
}

</script>


    <!--                                                               -->
    <!-- Consider inlining CSS to reduce the number of requested files -->
    <!--                                                               -->
    <link type="text/css" rel="stylesheet" href="EMStatic.css">

    <!--                                           -->
    <!-- Any title is fine                         -->
    <!--                                           -->
    <title>Web Application Starter Project</title>
    
    <script type="text/javascript" language="javascript" src="emstatic.js"></script>

    <!--                                           -->
    <!-- This script loads your compiled module.   -->
    <!-- If you add any GWT meta tags, they must   -->
    <!-- be added before this line.                -->
    <!--                                           -->
    <script type="text/javascript" language="javascript" src="emstatic/emstatic.nocache.js"></script>
  </head>

  <!--                                           -->
  <!-- The body can have arbitrary html, or      -->
  <!-- you can leave the body empty if you want  -->
  <!-- to create a completely dynamic UI.        -->
  <!--                                           -->
  <body>

    <!-- RECOMMENDED if your web app will not function without JavaScript enabled -->
    <noscript>
      <div style="width: 22em; position: absolute; left: 50%; margin-left: -11em; color: red; background-color: white; border: 1px solid red; padding: 4px; font-family: sans-serif">
        Your web browser must have JavaScript enabled
        in order for this application to display correctly.
      </div>
    </noscript>
  </body>
</html>


