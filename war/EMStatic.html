<!doctype html>
<!-- The DOCTYPE declaration above will set the     -->
<!-- browser's rendering engine into                -->
<!-- "Standards Mode". Replacing this declaration   -->
<!-- with a "Quirks Mode" doctype is not supported. -->

<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">

<style>
.disabled {
        color: lightgray
}
.topSpace {
        margin-top: 12px;
}

.gwt-MenuItem-disabled {
        color: lightgray;
}
.offScreen {
        position: absolute;
        right: 101%;
        overflow: hidden;
}
.gwt-Frame{
        scrolling="no";
        border: 0px !important;
}

.gwt-MenuItem {
        font-size: 12px !important;
}

.gwt-MenuBar-horizontal {
        font-size: 12px !important;
        }
        
.gwt-Label-selected {
        font-size: 1.3em;
        font-weight: 700;
        border-top: 1px solid black;
        border-bottom: 1px solid black;
}
.gwt-Label-1off {
        color: DarkGray;
}

.gwt-Label-2off {
        font-size:0.8em;
        color: LightGray;
}

.gwt-Label-current {
}


</style>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="tess2.js"></script>

<script id="shader-display-fs" type="x-shader/x-fragment">
#define TS_COL_WALL 0
#define TS_COL_POS 1
#define TS_COL_NEG 2
#define TS_COL_NEUTRAL 3
#define TS_COL_POS_MED 4
#define TS_COL_NEG_MED 5
#define TS_COL_MED 6
#define TS_COL_SOURCE 7
#define TS_COL_COUNT  9

    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;

    uniform sampler2D uSampler;
    uniform sampler2D uRightSideTexture;
    uniform float brightness;
    uniform lowp vec3 colors[TS_COL_COUNT];

	// shader for displaying potential (not default which is field vectors)
    void main(void) {
        float alpha = 1.0;
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        vec4 rightSideColor = texture2D(uRightSideTexture, vec2(vTextureCoord.s, vTextureCoord.t));

		// blue channel used to store walls/media
		float med = rightSideColor.b;
		vec3 col;
		if (med == 0.0)
			col = colors[TS_COL_WALL];
		else {
			// red channel used to store potential
			float r =  textureColor.r*brightness;
	        r = clamp(r, -1., 1.);
            if (r > 0.0)
            	col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                			mix(colors[TS_COL_POS_MED], colors[TS_COL_POS], med), r);
            else
                col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med),
                		    mix(colors[TS_COL_NEG_MED], colors[TS_COL_NEG], med), -r);
		}
//gl_FragColor = vec4(textureColor.rgb * brightness, 1.);
        gl_FragColor = vec4(col, 1.);
    }
</script>

<script id="shader-equipotential-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;

    uniform sampler2D uSampler;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;
    uniform float brightness;

    void main(void) {
        float alpha = 1.0;
	vec4 rs = texture2D(uRightSideTexture, vec2(vTextureCoord.s, vTextureCoord.t));
        if (rs.b == 0.0) {
          gl_FragColor = vec4(.5, .5, .5, 1.);
        } else {
          vec4 texture0 = texture2D(uSampler, vec2(vTextureCoord.s-stepSizeX, vTextureCoord.t));
          vec4 textureS = texture2D(uSampler, vec2(vTextureCoord.s+stepSizeX, vTextureCoord.t));
          vec4 textureA = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t-stepSizeY));
          vec4 textureT = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t+stepSizeY));
  
	  float pot0 =  texture0.r*brightness;
	  float potS =  textureS.r*brightness;
	  float potT =  textureT.r*brightness;
	  float potA =  textureA.r*brightness;
          gl_FragColor = (floor(pot0) != floor(potS) || floor(potA) != floor(potT)) ? vec4(1., 1., 1., 1.) :
                 vec4(1., 1., 1., rs.b != 1.0 || rs.g != 0.0 ? 0.15 : 0.0);
       }
    }
</script>

<script id="shader-draw-fs" type="x-shader/x-fragment">
    precision mediump float;

    //varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
</script>

<script id="shader-draw-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
		vColor = aColor;
    }
</script>

<script id="shader-view-charge-fs" type="x-shader/x-fragment">
    varying highp vec2 vTextureCoord;
    uniform sampler2D uSourceTexture;
    uniform highp float brightness;

    void main(void) {
        highp vec4 tx = texture2D(uSourceTexture, vTextureCoord);
        gl_FragColor = tx.r > 0. ? mix(vec4(.5, .5, .5, 1.), vec4(1., 1., 0., 1.), brightness*( tx.r)) :
                                   mix(vec4(.5, .5, .5, 1.), vec4(0., 0., 1., 1.), brightness*(-tx.r));
    }
</script>

<script id="shader-view-charge-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uTextureMatrix;

    varying vec4 vPosition;
    varying vec2 vTextureCoord;

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = (uTextureMatrix * vec4(aVertexPosition.x, aVertexPosition.y, 0.0, 1.0)).xy;
    }
</script>

<script id="shader-calc-charge-fs" type="x-shader/x-fragment">
    varying highp vec2 vTextureCoord;
    varying highp vec2 vTextureCoordUp;
    varying highp vec2 vTextureCoordDown;
    varying highp vec2 vTextureCoordLeft;
    varying highp vec2 vTextureCoordRight;
    uniform sampler2D uSourceTexture;

    void main(void) {
        highp vec4 t0 = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 tu = texture2D(uSourceTexture, vTextureCoordUp);
        highp vec4 td = texture2D(uSourceTexture, vTextureCoordDown);
        highp vec4 tl = texture2D(uSourceTexture, vTextureCoordLeft);
        highp vec4 tr = texture2D(uSourceTexture, vTextureCoordRight);
        gl_FragColor = vec4((t0.r-tu.r)*tu.b+(t0.r-td.r)*td.b+(t0.r-tl.r)*tl.b+(t0.r-tr.r)*tr.b, 0.0, 0.0, 1.0);
    }
</script>

<script id="shader-calc-charge-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uTextureMatrix;

    varying vec4 vPosition;
    varying vec2 vTextureCoord;
    varying vec2 vTextureCoordUp;
    varying vec2 vTextureCoordDown;
    varying vec2 vTextureCoordLeft;
    varying vec2 vTextureCoordRight;

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = (uTextureMatrix  * vec4(aVertexPosition.x, aVertexPosition.y, 0.0, 1.0)).xy;
        vTextureCoordUp = (uTextureMatrix  * vec4(aVertexPosition.x, aVertexPosition.y+1.0, 0.0, 1.0)).xy;
        vTextureCoordDown = (uTextureMatrix  * vec4(aVertexPosition.x, aVertexPosition.y-1.0, 0.0, 1.0)).xy;
        vTextureCoordLeft = (uTextureMatrix  * vec4(aVertexPosition.x-1.0, aVertexPosition.y, 0.0, 1.0)).xy;
        vTextureCoordRight = (uTextureMatrix  * vec4(aVertexPosition.x+1.0, aVertexPosition.y, 0.0, 1.0)).xy;
    }
</script>

<script id="shader-mode-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vPosition;
	varying vec4 vColor;

    void main(void) {
		// used to paint mode boxes
        gl_FragColor = vec4(sin(vColor.r)*sin(vColor.g)+sin(vColor.b)*sin(vColor.a), 0., 0., 0.);
    }
</script>

<script id="shader-copy-rg-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    uniform sampler2D uSourceTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        gl_FragColor = vec4(pv.rg, 1., 1.);
}

</script>

<script id="shader-copy-rgb-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    uniform sampler2D uSourceTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        gl_FragColor = vec4(pv.rgb, 1.);
}

</script>

<script id="shader-simulate-fs" type="x-shader/x-fragment">
	// shader for running simulation
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;

highp vec4 getSquare(highp vec2 offset)
{
        highp vec2 x = offset+vTextureCoord;
	highp vec4 q = texture2D(uSourceTexture, x);
	highp vec4 q2 = texture2D(uRightSideTexture, x);
        // switch conductors to space to avoid problems with charged conductors (need a better way to fix this)
        return vec4(q.r, q.g, q2.b > 0.0 ? q2.b : 1.0, q2.a);
}

void main()
{
    	highp float newpot = 0.;
        highp vec4 sv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        if (rv.b > 0.0) {
          highp vec4 mid0 = getSquare(vec2(0., 0.));
          highp vec4 mid1 = getSquare(vec2(stepSizeX, 0.));
          highp vec4 mid2 = getSquare(vec2(0., stepSizeY));
          highp vec4 mid3 = getSquare(vec2(-stepSizeX, 0.));
          highp vec4 mid4 = getSquare(vec2(0., -stepSizeY));
          highp vec4 mid5 = getSquare(vec2(-stepSizeX, -stepSizeY));
          highp float a0 = mid0.b + mid3.b + mid4.b + mid5.b;
          highp float a1 = .5*(mid0.b+mid4.b);
          highp float a2 = .5*(mid3.b+mid0.b);
          highp float a3 = .5*(mid5.b+mid3.b);
          highp float a4 = .5*(mid4.b+mid5.b);
          newpot = (a1*mid1.r+a2*mid2.r+a3*mid3.r+a4*mid4.r + rv.g*stepSizeX*stepSizeY)/a0;
        } else
	  newpot = rv.g;
        gl_FragColor = vec4(newpot, 0., sv.b, 1.);
}

</script>

<script id="shader-residual-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;

highp vec4 getSquare(highp vec2 offset)
{
        highp vec2 x = offset+vTextureCoord;
	highp vec4 q = texture2D(uSourceTexture, x);
	highp vec4 q2 = texture2D(uRightSideTexture, x);
        // switch conductors to space to avoid problems with charged conductors (need a better way to fix this)
        return vec4(q.r, q.g, q2.b > 0.0 ? q2.b : 1.0, q2.a);
}

void main()
{
    	highp float newpos = 0.;
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        if (rv.b > 0.0) {
          highp float pos = pv.r;
          highp vec4 mid0 = getSquare(vec2(0., 0.));
          highp vec4 mid1 = getSquare(vec2(stepSizeX, 0.));
          highp vec4 mid2 = getSquare(vec2(0., stepSizeY));
          highp vec4 mid3 = getSquare(vec2(-stepSizeX, 0.));
          highp vec4 mid4 = getSquare(vec2(0., -stepSizeY));
          highp vec4 mid5 = getSquare(vec2(-stepSizeX, -stepSizeY));
          highp float a0 = mid0.b + mid3.b + mid4.b + mid5.b;
          highp float a1 = .5*(mid0.b+mid4.b);
          highp float a2 = .5*(mid3.b+mid0.b);
          highp float a3 = .5*(mid5.b+mid3.b);
          highp float a4 = .5*(mid4.b+mid5.b);
          newpos = 4./(stepSizeX*stepSizeY) * ((a1*mid1.r+a2*mid2.r+a3*mid3.r+a4*mid4.r + rv.g*stepSizeX*stepSizeY)/a0 - pos);
        }
        gl_FragColor = vec4(0.0, newpos, 1., 1.);
}

</script>

<script id="shader-sum-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;

    uniform sampler2D uSourceTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;

highp vec4 getSquare(highp vec2 offset)
{
        highp vec2 x = offset+vTextureCoord;
	return texture2D(uSourceTexture, x);
}

void main()
{
    	highp float newpos = 0.;
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 mid1 = getSquare(vec2(stepSizeX, 0.));
        highp vec4 mid2 = getSquare(vec2(0., stepSizeY));
        highp vec4 mid3 = getSquare(vec2(stepSizeX, stepSizeY));
        gl_FragColor = vec4(pv.r + mid1.r + mid2.r + mid3.r, 0.0, 1., 1.);
}

</script>

<script id="shader-add-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        gl_FragColor = vec4(pv.r+rv.r, pv.g+rv.g, pv.b, 1.0);
}

</script>

<script id="shader-subtract-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;

    uniform sampler2D uSourceTexture;
    uniform sampler2D uRightSideTexture;

void main()
{
        highp vec4 pv = texture2D(uSourceTexture, vTextureCoord);
        highp vec4 rv = texture2D(uRightSideTexture, vTextureCoord);
        gl_FragColor = vec4(pv.r-rv.r, pv.g, pv.b, 1.0);
}

</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute float aDamping;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;
    varying vec4 vPosition;
    varying float vDamping;


    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
	vDamping = aDamping;
    }
</script>

<script id="shader-3d-vs" type="x-shader/x-vertex">
#define TS_COL_WALL 0
#define TS_COL_POS 1
#define TS_COL_NEG 2

#define TS_COL_POS_MED 4
#define TS_COL_NEG_MED 5
#define TS_COL_MED 6
#define TS_COL_SOURCE 7
#define TS_COL_NEUTRAL 8
#define TS_COL_COUNT 9

    attribute highp vec2 aTextureCoord;
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat4 uNormalMatrix;
    uniform highp float xOffset;

    varying vec2 vTextureCoord;
    //varying vec4 vPosition;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float brightness;
    uniform lowp vec3 colors[TS_COL_COUNT];

    void main(void) {
	highp vec2 tc  = vec2(aTextureCoord.x+xOffset, aTextureCoord.y);
        vec4 pv = texture2D(uSampler, tc);
	float r =  pv.r*brightness*.1;
        vec4 vPosition = uMVMatrix * vec4(-1.0+2.0*tc.x, -1.0+2.0*tc.y, r, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = tc;
	float med = 1.0; // pv.b;
	vec3 col;
	if (med == 0.0)
	  col = colors[TS_COL_WALL];
	else {
	  // calculate normal
	  float qx = texture2D(uSampler, vec2(aTextureCoord.x+xOffset+1./200., aTextureCoord.y)).r-pv.r;
	  float qy = texture2D(uSampler, vec2(aTextureCoord.x+xOffset, aTextureCoord.y+1./200.)).r-pv.r;
	  qx *= brightness*20.;  qy *= brightness*20.;

	  // calculate lighting
	  float normdot = max(dot(uNormalMatrix*vec4(qx, qy, -1., 1.), vec4(1., 0., -1., 0.))/length(vec3(qx, qy, -1.)), 0.0);

	  r = 10.*clamp(r, -1., 1.);
          if (r > 0.0)
            col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med), mix(colors[TS_COL_POS_MED], colors[TS_COL_POS], med), r);
          else
            col = mix(mix(colors[TS_COL_MED], colors[TS_COL_NEUTRAL], med), mix(colors[TS_COL_NEG_MED], colors[TS_COL_NEG], med), -r);
	  // not sure why we need this clamp here but it doesn't work otherwise
	  col = clamp(col, 0., 1.) + vec3(1., 1., 1.)*normdot*.6;
	}
        vColor = vec4(col, 1.);
    }
</script>

<script id="shader-3d-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform sampler2D uRightSideTexture;
    uniform float stepSizeX;
    uniform float stepSizeY;
    uniform highp float equipMult;

    void main(void) {
        float alpha = 1.0;
	vec4 rs = texture2D(uRightSideTexture, vec2(vTextureCoord.s, vTextureCoord.t));
        if (rs.b == 0.0) {
          gl_FragColor = vec4(.5, .5, .5, 1.);
        } else {
          vec4 texture0 = texture2D(uSampler, vec2(vTextureCoord.s-stepSizeX, vTextureCoord.t));
          vec4 textureS = texture2D(uSampler, vec2(vTextureCoord.s+stepSizeX, vTextureCoord.t));
          vec4 textureA = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t-stepSizeY));
          vec4 textureT = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t+stepSizeY));
  
	  float pot0 =  texture0.r*equipMult;
	  float potS =  textureS.r*equipMult;
	  float potT =  textureT.r*equipMult;
	  float potA =  textureA.r*equipMult;
          gl_FragColor = (floor(pot0) != floor(potS) || floor(potA) != floor(potT)) ? vec4(1., 1., 1., 1.) : vColor;
       }
    }
</script>

<script id="shader-field-vs" type="x-shader/x-vertex">

attribute highp vec2 aVertexPosition;
uniform sampler2D uSampler;
varying vec3 vColor;
uniform float stepSizeX;
uniform float stepSizeY;
uniform float brightness;
varying mat2 vMatrix;
uniform mat3 uTextureMatrix;

highp vec4 getSquare(highp vec2 coords, highp float offsetX, highp float offsetY) {
  return texture2D(uSampler, (uTextureMatrix * vec3(coords.x+offsetX, coords.y+offsetY, 1.0)).xy);
}

void main() {
  highp vec4 pa = getSquare(aVertexPosition,  stepSizeX, 0.);
  highp vec4 pb = getSquare(aVertexPosition, -stepSizeX, 0.);
  highp vec4 pc = getSquare(aVertexPosition, 0.,  stepSizeY);
  highp vec4 pd = getSquare(aVertexPosition, 0., -stepSizeY);
  vec2 grad = -vec2(pb.r-pa.r, pc.r-pd.r);
  float len = length(grad);
  float col = len*brightness*10.0;
  vColor = col > 1.0 ? vec3(col-1.0, 1.0, col-1.0) : vec3(0.0, col, 0.0);
  vMatrix = mat2(grad.y/len, grad.x/len, -grad.x/len, grad.y/len);
  gl_Position = vec4(aVertexPosition.xy, 0.0, 1.0);
  gl_PointSize = 16.0;
  
}

</script>

<script id="shader-field-fs" type="x-shader/x-fragment">

varying highp vec3 vColor;
varying highp mat2 vMatrix;
uniform sampler2D uArrowTexture;

void main() {
  highp vec2 pc = gl_PointCoord;
  pc = vMatrix*(pc-vec2(0.5, 0.5)) + vec2(0.5, 0.5);
  gl_FragColor = vec4(texture2D(uArrowTexture, pc).rgb * vColor, 1.0);
}

</script>


    <!--                                                               -->
    <!-- Consider inlining CSS to reduce the number of requested files -->
    <!--                                                               -->
    <link type="text/css" rel="stylesheet" href="EMStatic.css">

    <!--                                           -->
    <!-- Any title is fine                         -->
    <!--                                           -->
    <title>Web Application Starter Project</title>
    
    <script type="text/javascript" language="javascript" src="emstatic.js"></script>

    <!--                                           -->
    <!-- This script loads your compiled module.   -->
    <!-- If you add any GWT meta tags, they must   -->
    <!-- be added before this line.                -->
    <!--                                           -->
    <script type="text/javascript" language="javascript" src="emstatic/emstatic.nocache.js"></script>
  </head>

  <!--                                           -->
  <!-- The body can have arbitrary html, or      -->
  <!-- you can leave the body empty if you want  -->
  <!-- to create a completely dynamic UI.        -->
  <!--                                           -->
  <body>

    <!-- RECOMMENDED if your web app will not function without JavaScript enabled -->
    <noscript>
      <div style="width: 22em; position: absolute; left: 50%; margin-left: -11em; color: red; background-color: white; border: 1px solid red; padding: 4px; font-family: sans-serif">
        Your web browser must have JavaScript enabled
        in order for this application to display correctly.
      </div>
    </noscript>
  </body>
</html>


